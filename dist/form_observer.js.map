{"version":3,"sources":["webpack://form_observer/webpack/universalModuleDefinition","webpack://form_observer/webpack/bootstrap","webpack://form_observer/./node_modules/mdn-polyfills/Object.assign.js","webpack://form_observer/./node_modules/mdn-polyfills/NodeList.prototype.forEach.js","webpack://form_observer/./node_modules/mdn-polyfills/CustomEvent.js","webpack://form_observer/./node_modules/mdn-polyfills/Object.entries.js","webpack://form_observer/./src/core/ConsoleExtend.js","webpack://form_observer/./src/core/HTMLRadioGroup.js","webpack://form_observer/./src/core/FormControlsCollection.js","webpack://form_observer/./src/FormObserver.js"],"names":["condition","messages","console","log","HTMLRadioGroup","radioInput","_list","type","localName","add","push","e","checkedRadio","dispatchEvent","listener","options","forEach","radioControl","addEventListener","filter","element","checked","value","radioToCheck","warn","el","FormControlsCollection","target","settings","_settings","controlsSelector","triggerChangeOnSetter","consoleVerbose","Object","assign","_target","_controls","_data","_parseControls","querySelectorAll","join","control","controlType","_getControlType","name","_getControlValue","htmlRadioGroup","parse","_defineMethods","_addEventListeners","_extendValueProperty","eventName","conditionalLog","defineProperty","_createGetter","_createSetter","controlName","self","includes","realHTMLInputElement","getPrototypeOf","set","call","getOwnPropertyDescriptor","get","newValue","_setControlValue","toLowerCase","stopPropagation","currentValue","changeEvent","CustomEvent","bubbles","iteratorFunction","keys","key","replace","data","nonValidKeys","length","index","values","returnObject","json","entries","obj","JSON","stringify","FormObserver","fillData","prefix","init","error","serializeControls","fillForm","formElements","form","toJSON"],"mappings":"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","file":"form_observer.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"form_observer\"] = factory();\n\telse\n\t\troot[\"form_observer\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","\"function\"!=typeof Object.assign&&(Object.assign=function(n){if(null==n)throw new TypeError(\"Cannot convert undefined or null to object\");for(var r=Object(n),t=1;t<arguments.length;t++){var e=arguments[t];if(null!=e)for(var o in e)e.hasOwnProperty(o)&&(r[o]=e[o])}return r});\n","window.NodeList&&!NodeList.prototype.forEach&&(NodeList.prototype.forEach=function(o,t){t=t||window;for(var i=0;i<this.length;i++)o.call(t,this[i],i,this)});\n","!function(){function t(t,e){e=e||{bubbles:!1,cancelable:!1,detail:void 0};var n=document.createEvent(\"CustomEvent\");return n.initCustomEvent(t,e.bubbles,e.cancelable,e.detail),n}\"function\"!=typeof window.CustomEvent&&(t.prototype=window.Event.prototype,window.CustomEvent=t)}();\n","\"function\"!=typeof Object.entries&&(Object.entries=function(e){for(var t=Object.keys(e),n=t.length,r=new Array(n);n--;)r[n]=[t[n],e[t[n]]];return r});\n","export default function(condition, ...messages) {\n  if (condition) {\n    console.log(...messages);\n  }\n}","class HTMLRadioGroup {\n  /**\n   * @param {*} radioInput \n   */\n  constructor(radioInput) {\n    /**\n     * @type {HTMLInputElement[]}\n     */\n    this._list = [];\n\n    this.type = 'radio';\n    this.localName = 'input';\n\n    this.add(radioInput);\n  }\n\n  /**\n   * \n   * @param {*} radioInput \n   */\n  add(radioInput) {\n    this._list.push(radioInput);\n  }\n\n  /**\n   * \n   * @param {Event} e \n   */\n  dispatchEvent(e) {\n    const checkedRadio = this.checkedRadio;\n\n    if (checkedRadio) {\n      checkedRadio.dispatchEvent(e)\n    }\n  }\n\n\n  /**\n   * @param {string} type \n   * @param {EventListenerOrEventListenerObject} listener \n   * @param {boolean? | AddEventListenerOptions} options \n   */\n  addEventListener(type, listener, options) {\n    this._list.forEach(radioControl => {\n      radioControl.addEventListener(type, listener, options);\n    })\n  }\n\n  get checkedRadio() {\n    let radioInput = this._list.filter(element => {\n      return element.checked;\n    })\n\n    return radioInput[0];\n  }\n\n  get value() {\n    const checkedRadio = this.checkedRadio;\n\n    if (checkedRadio) {\n      return checkedRadio.value\n    } else {\n      return false;\n    }\n  }\n\n  set value(value) {\n    /**\n     * @type {HTMLInputElement}\n     */\n    let radioToCheck = this._list.filter((element) => {\n      return element.value === value;\n    })[0]\n\n    if (radioToCheck) {\n      radioToCheck.checked = true;\n    } else {\n      console.warn('The specified value was not found in the required RadioGroup.')\n    }\n  }\n\n  get checked() {\n    return !!this.checkedRadio\n  }\n\n\n  /**\n   * @param {*} el \n   * @return {HTMLRadioGroup}\n   */\n  static parse(el) {\n    return el;\n  }\n}\n\nexport { HTMLRadioGroup };","import \"mdn-polyfills/NodeList.prototype.forEach\";\nimport \"mdn-polyfills/CustomEvent\";\nimport \"mdn-polyfills/Object.entries\";\n\nimport conditionalLog from \"./ConsoleExtend\";\nimport { HTMLRadioGroup } from \"./HTMLRadioGroup\";\n\n/**\n * @typedef { HTMLRadioGroup | HTMLInputElement | HTMLTextAreaElement } HTMLFormControlElement\n */\n\n/**\n * I'm not using Proxy due to compatibility issues.\n * In fact this library is compatible even with IE9.\n */\nclass FormControlsCollection {\n  /**\n   * @param {HTMLElement | HTMLFormElement} target\n   * @param {Object?} settings\n   */\n  constructor(target, settings) {\n    /**\n     * @private\n     */\n    this._settings = {\n      controlsSelector: [\n        'input:not([type=\"button\"]):not([type=\"submit\"]):not([type=\"reset\"])',\n        'textarea',\n        'select'\n      ],\n      triggerChangeOnSetter: false,\n      consoleVerbose: false\n    }\n\n\n    if (settings) {\n      Object.assign(this._settings, settings);\n    }\n\n    /**\n     * @private\n     * @type {HTMLElement | HTMLFormElement}\n     */\n    this._target = target;\n\n    /**\n     * @private\n     * @type {Object.<string, HTMLFormControlElement>}\n     */\n    this._controls = {};\n\n    /**\n     * @private\n     * @type {Object.<string, string|boolean>}\n     */\n    this._data = {};\n\n    this._parseControls();\n  }\n\n  /**\n   * @private\n   */\n  _parseControls() {\n    /**\n     * @type {NodeList}\n     */\n    const _controls = this._target.querySelectorAll(this._settings.controlsSelector.join(','));\n\n    _controls.forEach(\n      /**\n       * @param {*} control\n       */\n      control => {\n        const controlType = this._getControlType(control);\n        /**\n         * @type {string}\n         */\n        const name = control['name'];\n        /**\n         * @type {string | Boolean}\n         */\n        const value = this._getControlValue(control);\n\n        // If the control doesn't have a name, skips it.\n        if (!name) {\n          return;\n        }\n\n        this._data['_' + name] = value ? value : (this._data['_' + name] || '');\n\n        // If the control is a Radio, instantiate a new HTMLRadioGroup element that\n        // will contain all the radios with the same name.\n        if (controlType === 'radio') {\n          /**\n           * @type {HTMLRadioGroup}\n           */\n          let htmlRadioGroup = HTMLRadioGroup.parse(this._controls['_' + name]);\n\n          // If the key has already been added, concat the new control with the existing ones\n          if (htmlRadioGroup) {\n            htmlRadioGroup.add(control)\n          } else {\n            this._controls['_' + name] = new HTMLRadioGroup(control);\n          }\n        } else {\n          this._controls['_' + name] = control;\n        }\n\n        this._defineMethods(name);\n        this._addEventListeners(control);\n        this._extendValueProperty(control, controlType, name);\n      });\n  }\n\n  /**\n   * @param {HTMLFormControlElement} control \n   */\n  _addEventListeners(control) {\n    let eventName = 'input';\n    let controlType = this._getControlType(control);\n\n    switch (controlType) {\n      case \"radio\":\n      case \"checkbox\":\n      case \"select\":\n        eventName = 'change';\n        break;\n    }\n\n    // @ts-ignore\n    control.addEventListener(eventName,\n      /**\n       * @param {Event} e\n       */\n      e => {\n        if (e['selfTriggered']) {\n          return;\n        }\n\n        /**\n         * @type {*}\n         */\n        let target = e.target;\n        let value = this._getControlValue(target);\n\n        conditionalLog(this._settings.consoleVerbose, 'OnControlInput');\n\n        this[target.name] = value;\n      })\n  }\n\n  /**\n   * Defines a method for the specified name that return the HTMLElement.\n   * The name is in camelCase with the prefix \"get\".\n   * \n   * @example \n   * this.getEmail() -> // return the HTMLElement\n   * \n   * @param {string} name \n   */\n  _defineMethods(name) {\n    if (name in this) {\n      return;\n    }\n\n    Object.defineProperty(this, name, {\n      ...this._createGetter(name),\n      ...this._createSetter(name)\n    })\n  }\n\n  /**\n   * Extends the original setter for 'value' property, so that each\n   * time a user calls the value setter, this will update also the local object\n   * that contains the control values.\n   * \n   * \n   * Technically this extension of the value setter is useless because the user should\n   * never call this setter manually. Instead should set the new value using the object\n   * provided by this library.\n   * But, to avoid compatibility problems with already written code, i added this extension.\n   *  \n   * \n   * @param {HTMLElement} control \n   * @param {string} controlType \n   * @param {string} controlName \n   */\n  _extendValueProperty(control, controlType, controlName) {\n    let self = this;\n\n    // Avoid changing the value setter for select, radio and checkbox\n    if (['select', 'radio', 'checkbox'].includes(controlType)) {\n      return;\n    }\n\n    // Creates an IIFE that stores the original setter for value property,\n    // so that this can be called once the personal setter has been executed.\n    (function(realHTMLInputElement) {\n      Object.defineProperty(Object.getPrototypeOf(control), 'value', {\n        set: function(value) {\n          self._data[controlName] = value;\n\n          return realHTMLInputElement.set.call(this, value);\n        },\n      });\n    }(Object.getOwnPropertyDescriptor(Object.getPrototypeOf(control), 'value')));\n  }\n\n  /**\n   * @private\n   * @param {string} name\n   * @return {object}\n   */\n  _createGetter(name) {\n    return {\n      get: () => {\n        conditionalLog(this._settings.consoleVerbose, 'Getter');\n        return this._data['_' + name];\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @param {string} name\n   * @return {object}\n   */\n  _createSetter(name) {\n    return {\n      set:\n        /**\n         * @param {string} newValue\n         */\n        newValue => {\n          // Avoid updating the value if is the same.\n          if (this._data['_' + name] === newValue) {\n            return;\n          }\n\n          conditionalLog(this._settings.consoleVerbose, 'Setter');\n\n          // Updates the value in the object\n          this._data['_' + name] = newValue;\n\n          // Then updates the value of the HTMLElement\n          this._setControlValue(this._controls['_' + name], newValue);\n        }\n    }\n  }\n\n  /**\n   * @private\n   * @param {HTMLFormControlElement} control\n   * @return {string | Boolean}\n   */\n  _getControlValue(control) {\n    let controlType = this._getControlType(control);\n    let value;\n\n    // For selectControl behaves as normal\n    switch (controlType) {\n      case 'radio':\n        value = control['checked'] ? control.value : false;\n\n        break;\n      case 'checkbox':\n        value = control['checked'] ? control.value : false;\n\n        break;\n      default:\n        value = control.value;\n    }\n\n    return value;\n  }\n\n  /**\n   * @param {HTMLFormControlElement} control\n   */\n  _getControlType(control) {\n    let controlType = control.localName.toLowerCase();\n\n    if (controlType === 'input') {\n      controlType = control.type;\n    }\n\n    return controlType;\n  }\n\n  /**\n   * @private\n   * @param {HTMLFormControlElement} control \n   * @param {string} value \n   */\n  _setControlValue(control, value, stopPropagation = false) {\n    let controlType = this._getControlType(control);\n    let currentValue = this._getControlValue(control);\n\n    // Avoid updating the control if the value is the same.\n    if (currentValue === value) {\n      return;\n    }\n\n    switch (controlType) {\n      case 'radio':\n        control.value = value;\n\n        break;\n      case 'checkbox':\n        control['checked'] = !!value;\n\n        break;\n      case 'select':\n        control.value = value;\n\n        // Updates the value stored for the select because if the user tries to set a value \n        // that doesn't exist, the select will be resetted, so the value stored must be updated\n        this._data['_' + control[\"name\"]] = control.value;\n        break;\n      default:\n        control.value = value;\n    }\n\n    conditionalLog(this._settings.consoleVerbose, 'SetControlValue');\n\n    if (this._settings.triggerChangeOnSetter && !stopPropagation) {\n      const changeEvent = new CustomEvent('change', { bubbles: true });\n\n      changeEvent['selfTriggered'] = true;\n\n      conditionalLog(this._settings.consoleVerbose, 'DispatchChangeEvent');\n\n      control.dispatchEvent(changeEvent);\n    }\n  }\n\n  /**\n   * Allow an iteration for each control in the target.\n   * This method extends the NodeList.forEach method.\n   * \n   * @param {function(HTMLFormControlElement, string):void} iteratorFunction \n   */\n  forEach(iteratorFunction) {\n    Object.keys(this._controls).forEach(key => {\n      iteratorFunction(this._controls[key], key.replace(\"_\", \"\"));\n    })\n  }\n\n  /**\n   * Fill the form with the data specified in the object 'data',\n   * where each key is the name of an existing control.\n   * \n   * @param {Object} data\n   */\n  assign(data) {\n    const nonValidKeys = [];\n\n    Object.keys(data).forEach(key => {\n      if ('_' + key in this._data) {\n        this[key] = data[key];\n      } else {\n        nonValidKeys.push(key)\n      }\n    });\n\n    // While assigning the value, if a key wasn't found, \n    // returns a console warn with the unknown keys.\n    if (nonValidKeys.length > 0) {\n      console.warn(\"The folowing fields weren't filled because they weren't found in the specified target.\\n\", nonValidKeys)\n    }\n  }\n\n  /**\n   * Returns the HTMLElement at the given index\n   * \n   * @param {Number} index\n   * @return {HTMLFormControlElement}\n   */\n  getItemAt(index) {\n    return Object.values(this._controls)[index];\n  }\n\n  /**\n   * Creates a method like 'get<ControlName>()' where 'ControlName' \n   * is the name of the control converted in CamelCase,\n   * that returns the HTMLElementof the control\n   * \n   * @param {string} name\n   * @return {HTMLFormControlElement | null}\n   */\n  getControl(name) {\n    conditionalLog(this._settings.consoleVerbose, 'getControl(' + name + ')');\n\n    return this._controls['_' + name];\n  }\n\n  /**\n   * Returns the data of the form in JSON format.\n   * If param 'returnObject' is true, returns an object instead of a string.\n   * \n   * @param {Boolean?} returnObject \n   * \n   * @return string | Object\n   */\n  toJSON(returnObject = false) {\n    let json = {};\n\n    Object.entries(this._data).forEach(obj => {\n      json[obj[0].replace('_', '')] = obj[1]\n    })\n\n    if (returnObject) {\n      return json;\n    }\n\n    return JSON.stringify(json);\n  }\n}\n\nexport { FormControlsCollection };","import \"mdn-polyfills/Object.assign\";\nimport { FormControlsCollection } from './core/FormControlsCollection';\n\nclass FormObserver {\n  /**\n   * @param {import('./FormObserver').FormObserverSettings} settings\n   */\n  constructor(settings, target = null, fillData = {}) {\n    /**\n     * @private\n     * @type {import('./FormObserver').FormObserverSettings}\n     */\n    this._settings = {\n      prefix: 'fo', // Form Observe\n      consoleVerbose: false,\n      triggerChangeOnSetter: false,\n      controlsSelector: [\n        'input:not([type=\\'button\\']):not([type=\\'submit\\']):not([type=\\'reset\\'])',\n        'textarea',\n        'select'\n      ]\n    };\n\n    // Merge the users settings with the default ones\n    if (settings) {\n      Object.assign(this._settings, settings);\n    }\n\n    if (target) {\n      return this.init(target, fillData);\n    }\n  }\n\n  /**\n   * Initialize the FormObserver on the specified HTMLElement.\n   * \n   * @param {HTMLFormElement | HTMLElement } target\n   * @param {Object?} fillData\n   * \n   * @return {FormControlsCollection}\n   */\n  init(target, fillData) {\n    if (!target) {\n      console.error('No valid target provided');\n      return;\n    }\n\n    target[this._settings.prefix] = this.serializeControls(target);\n\n    if (fillData) {\n      this.fillForm(target[this._settings.prefix], fillData)\n    }\n\n    return target[this._settings.prefix];\n  }\n\n  /**\n   * Serialize a Form end return its Controls as a FormControlsCollection\n   * \n   * @param {HTMLElement | HTMLFormElement} target\n   * \n   * @return {FormControlsCollection}\n   */\n  serializeControls(target) {\n    /**\n     * @type {FormControlsCollection}\n     */\n    let formElements = new FormControlsCollection(target, this._settings);\n\n    return formElements;\n  }\n\n  /**\n   * Fill the form with the data in the given Object.\n   * Each key of the object must correspond to the name of an existing control.\n   * \n   * @param {FormControlsCollection} target \n   * @param {Object} fillData \n   */\n  fillForm(target, fillData) {\n    target.assign(fillData);\n  }\n\n  /**\n   * Returns the data of the form in JSON format.\n   * If param 'returnObject' is true, returns an object instead of a string.\n   * \n   * @param {HTMLFormElement | HTMLElement} form \n   * @param {Boolean?} returnObject\n   *  \n   * @return string | Object\n   */\n  toJSON(form, returnObject = false) {\n    if (form[this._settings.prefix]) {\n      return form[this._settings.prefix].toJSON(returnObject);\n    }\n\n    return {};\n  }\n\n  /**\n   * @return {import('./FormObserver').FormObserverSettings}\n   */\n  get settings() {\n    return this._settings;\n  }\n}\n\nexport default FormObserver;  \nexport { FormObserver };  "],"sourceRoot":""}